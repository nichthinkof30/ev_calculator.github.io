<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>EV Charger ROI Calculator</title>
    <meta name="description" content="EV Charger ROI Calculator Dashboard" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Bootstrap CSS -->
    <link
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <style>
      body {
        background-color: #f0f2f5;
      }
      .header {
        background-color: #fff;
        border-bottom: 1px solid #e5e5e5;
        padding: 15px 20px;
        text-align: center;
      }
      .content {
        padding: 20px;
      }
      .card {
        margin-bottom: 20px;
      }
      .segment-row {
        border: 1px solid #ddd;
        padding: 10px;
        margin-bottom: 10px;
        border-radius: 4px;
        background-color: #fafafa;
      }
      .segment-header {
        font-weight: bold;
        margin-bottom: 10px;
      }
      canvas {
        margin-top: 20px;
      }
      .error {
        color: red;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h3>EV Charger ROI Calculator</h3>
    </div>
    <div class="container content">
      <div id="root"></div>
    </div>

    <!-- React, ReactDOM, Babel, Chart.js, jQuery, Bootstrap JS -->
    <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.2/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>

    <script type="text/babel">
      function ROICalculator() {
        // Global parameters
        const [costPerCharger, setCostPerCharger] = React.useState(5000);
        const [infrastructureCost, setInfrastructureCost] = React.useState(2000);
        const [chargerPowerRating, setChargerPowerRating] = React.useState(50); // in kW
        const [averageChargingPower, setAverageChargingPower] = React.useState(80); // in %
        const [electricityCost, setElectricityCost] = React.useState(0.5); // RM per kWh
        const [hostingCost] = React.useState(80); // RM
        const [maintenanceFee] = React.useState(350); // RM
        const [profitSharing, setProfitSharing] = React.useState(20); // in %
        const [projectionMonths, setProjectionMonths] = React.useState(12); // dynamic projection months

        // For daily segments, we initialize with one default segment covering 24 hours.
        const [segments, setSegments] = React.useState([
          { hours: 24, chargingFee: 1, utilizationRate: 30 }
        ]);

        // Hold validation error for segments
        const [segmentError, setSegmentError] = React.useState("");

        // For storing calculated result
        const [result, setResult] = React.useState(null);
        const daysInMonth = 30;

        // Validate that total hours from segments does not exceed 24.
        const validateSegments = () => {
          const totalHours = segments.reduce((sum, seg) => sum + Number(seg.hours || 0), 0);
          if (totalHours > 24) {
            setSegmentError("Total hours across segments cannot exceed 24.");
            return false;
          } else {
            setSegmentError("");
            return true;
          }
        };

        // When segments change, revalidate.
        React.useEffect(() => {
          validateSegments();
        }, [segments]);

        // Functions to handle segment changes
        const updateSegment = (index, field, value) => {
          const newSegments = [...segments];
          newSegments[index][field] = value;
          setSegments(newSegments);
        };

        const addSegment = () => {
          // Default new segment with 0 hours.
          setSegments([...segments, { hours: 0, chargingFee: 0, utilizationRate: 0 }]);
        };

        const removeSegment = (index) => {
          const newSegments = segments.filter((_, i) => i !== index);
          setSegments(newSegments);
        };

        // Calculate ROI based on segments.
        const calculateROI = () => {
          // If segments are invalid, do not calculate.
          if (!validateSegments()) return null;
          let totalEnergy = 0;
          let totalRevenue = 0;
          segments.forEach((seg) => {
            const segHours = Number(seg.hours);
            const segUtil = Number(seg.utilizationRate);
            const segFee = Number(seg.chargingFee);
            // Energy delivered for this segment over the month:
            const segEnergy = chargerPowerRating * (averageChargingPower / 100) * (segUtil / 100) * (segHours * daysInMonth);
            totalEnergy += segEnergy;
            totalRevenue += segEnergy * segFee;
          });
          const monthlyElectricityCost = totalEnergy * electricityCost;
          const monthlyExpenses = monthlyElectricityCost + hostingCost + maintenanceFee;
          const monthlyGrossProfit = totalRevenue - monthlyExpenses;
          const partnerPayment = monthlyGrossProfit * (profitSharing / 100);
          const monthlyNetProfit = monthlyGrossProfit - partnerPayment;
          const totalInvestment = costPerCharger + infrastructureCost;
          const monthlyROI = (monthlyNetProfit / totalInvestment) * 100;
          const annualROI = monthlyROI * 12;

          return {
            totalEnergy,
            totalChargingRevenue: totalRevenue,
            monthlyElectricityCost,
            monthlyExpenses,
            monthlyGrossProfit,
            partnerPayment,
            monthlyNetProfit,
            monthlyROI,
            annualROI,
            totalInvestment
          };
        };

        // Handle form submission to calculate ROI
        const handleSubmit = (e) => {
          e.preventDefault();
          const res = calculateROI();
          if (res) {
            setResult(res);
          }
        };

        // Compute Break Even Month:
        // Month 1: net income = -(setup cost + monthly expense)
        // Months 2+: net income = monthly net profit
        const getBreakEvenMonth = () => {
          if (!result) return null;
          let cumulative = 0;
          for (let i = 1; i <= projectionMonths; i++) {
            const monthlyIncome = i === 1
              ? -(result.totalInvestment + result.monthlyExpenses)
              : result.monthlyNetProfit;
            cumulative += monthlyIncome;
            if (cumulative >= 0) return i;
          }
          return "Not reached within projection period";
        };

        // Chart.js integration:
        // For cumulative net income: Month 1 uses -(setup cost + monthly expense), then add monthly net profit.
        // For expenses: Month 1 shows (setup cost + monthly expense), subsequent months show monthly expense.
        const chartRef = React.useRef(null);
        const chartInstanceRef = React.useRef(null);
        React.useEffect(() => {
          if (result) {
            let cumulativeNetIncome = [];
            let runningTotal = 0;
            for (let i = 1; i <= projectionMonths; i++) {
              const monthlyIncome = i === 1
                ? -(result.totalInvestment + result.monthlyExpenses)
                : result.monthlyNetProfit;
              runningTotal += monthlyIncome;
              cumulativeNetIncome.push(runningTotal);
            }
            let expenseValues = [];
            for (let i = 1; i <= projectionMonths; i++) {
              if (i === 1) {
                expenseValues.push(result.totalInvestment + result.monthlyExpenses);
              } else {
                expenseValues.push(result.monthlyExpenses);
              }
            }
            const labels = [];
            for (let i = 1; i <= projectionMonths; i++) {
              labels.push("M" + i);
            }
            if (chartInstanceRef.current) {
              chartInstanceRef.current.data.labels = labels;
              chartInstanceRef.current.data.datasets[0].data = cumulativeNetIncome;
              chartInstanceRef.current.data.datasets[1].data = expenseValues;
              chartInstanceRef.current.update();
            } else {
              const ctx = chartRef.current.getContext('2d');
              chartInstanceRef.current = new Chart(ctx, {
                type: 'line',
                data: {
                  labels: labels,
                  datasets: [
                    {
                      label: 'Cumulative Net Income (RM)',
                      data: cumulativeNetIncome,
                      segment: {
                        borderColor: ctx => ctx.p0.parsed.y < 0 ? 'red' : 'green'
                      },
                      backgroundColor: 'rgba(75, 192, 192, 0.2)',
                      fill: true,
                      tension: 0.1,
                    },
                    {
                      label: 'Total Expenses (RM)',
                      data: expenseValues,
                      borderColor: 'rgba(255, 99, 132, 1)',
                      backgroundColor: 'rgba(255, 99, 132, 0.2)',
                      fill: false,
                      tension: 0.1,
                    },
                  ],
                },
                options: {
                  responsive: true,
                  scales: {
                    y: { beginAtZero: true }
                  },
                },
              });
            }
          }
        }, [result, projectionMonths]);

        // Helper function for human-readable formatting
        const formatNumber = (num) => {
          return Number(num).toLocaleString('en-US', {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2,
          });
        };

        // Build table rows for projection months.
        // Table Columns: Month | Setup Cost | Total Revenue | Monthly Operation Expenses | Partner Profit Sharing | Monthly Net Income | Total Net Income
        const renderTableRows = () => {
          if (!result) return null;
          const rows = [];
          let cumulativeNetIncome = 0;
          for (let i = 1; i <= projectionMonths; i++) {
            const cumulativeRevenue = (i - 1) * result.totalChargingRevenue;
            const monthlyExpense = result.monthlyExpenses;
            const monthlyNetIncome = i === 1 
              ? -(result.totalInvestment + result.monthlyExpenses)
              : result.monthlyNetProfit;
            const partnerProfit = i === 1 ? 0 : result.partnerPayment;
            cumulativeNetIncome += monthlyNetIncome;
            rows.push(
              <tr key={i}>
                <td>{i}</td>
                <td>{i === 1 ? formatNumber(result.totalInvestment) : '-'}</td>
                <td>{formatNumber(cumulativeRevenue)}</td>
                <td>{formatNumber(monthlyExpense)}</td>
                <td>{formatNumber(partnerProfit)}</td>
                <td>{formatNumber(monthlyNetIncome)}</td>
                <td>{formatNumber(cumulativeNetIncome)}</td>
              </tr>
            );
          }
          return rows;
        };

        return (
          <div className="card">
            <div className="card-body">
              <form onSubmit={handleSubmit}>
                {/* Global Parameters */}
                <div className="form-group">
                  <label>Cost per Charger (RM):</label>
                  <input
                    type="number"
                    className="form-control"
                    value={costPerCharger}
                    onChange={(e) => setCostPerCharger(parseFloat(e.target.value))}
                  />
                </div>
                <div className="form-group">
                  <label>Infrastructure Cost (RM):</label>
                  <input
                    type="number"
                    className="form-control"
                    value={infrastructureCost}
                    onChange={(e) => setInfrastructureCost(parseFloat(e.target.value))}
                  />
                </div>
                <div className="form-group">
                  <label>Charger Power Rating (kW):</label>
                  <input
                    type="number"
                    className="form-control"
                    value={chargerPowerRating}
                    onChange={(e) => setChargerPowerRating(parseFloat(e.target.value))}
                  />
                </div>
                <div className="form-group">
                  <label>Average Charging Power (%):</label>
                  <input
                    type="number"
                    className="form-control"
                    value={averageChargingPower}
                    onChange={(e) => setAverageChargingPower(parseFloat(e.target.value))}
                  />
                </div>
                <div className="form-group">
                  <label>Electricity Cost (RM/kWh):</label>
                  <input
                    type="number"
                    className="form-control"
                    value={electricityCost}
                    onChange={(e) => setElectricityCost(parseFloat(e.target.value))}
                  />
                </div>
                <div className="form-group">
                  <label>Profit Sharing (% of Gross Profit):</label>
                  <input
                    type="number"
                    className="form-control"
                    value={profitSharing}
                    onChange={(e) => setProfitSharing(parseFloat(e.target.value))}
                  />
                </div>
                <div className="form-group">
                  <label>Projection Months:</label>
                  <input
                    type="number"
                    className="form-control"
                    value={projectionMonths}
                    onChange={(e) => setProjectionMonths(parseInt(e.target.value))}
                  />
                </div>

                {/* Daily Segments Section */}
                <div className="mt-4">
                  <h5>Daily Segments (Total hours must not exceed 24)</h5>
                  {segments.map((seg, index) => (
                    <div key={index} className="segment-row row">
                      <div className="col-4">
                        <label>Hours:</label>
                        <input
                          type="number"
                          className="form-control"
                          value={seg.hours}
                          onChange={(e) =>
                            updateSegment(index, "hours", Number(e.target.value))
                          }
                        />
                      </div>
                      <div className="col-4">
                        <label>Charging Fee (RM/kWh):</label>
                        <input
                          type="number"
                          className="form-control"
                          value={seg.chargingFee}
                          onChange={(e) =>
                            updateSegment(index, "chargingFee", Number(e.target.value))
                          }
                        />
                      </div>
                      <div className="col-3">
                        <label>Utilization Rate (%):</label>
                        <input
                          type="number"
                          className="form-control"
                          value={seg.utilizationRate}
                          onChange={(e) =>
                            updateSegment(index, "utilizationRate", Number(e.target.value))
                          }
                        />
                      </div>
                      <div className="col-1 d-flex align-items-end">
                        {segments.length > 1 && (
                          <button
                            type="button"
                            className="btn btn-sm btn-danger"
                            onClick={() => removeSegment(index)}
                          >
                            X
                          </button>
                        )}
                      </div>
                    </div>
                  ))}
                  {segmentError && <p className="error">{segmentError}</p>}
                  <button type="button" className="btn btn-secondary btn-sm" onClick={addSegment}>
                    Add Segment
                  </button>
                </div>

                <button type="submit" className="btn btn-primary mt-3">
                  Calculate ROI
                </button>
              </form>
              {result && !segmentError && (
                <div className="mt-4">
                  <h4>Results</h4>
                  <p>
                    <strong>Monthly Energy Delivered:</strong>{" "}
                    {formatNumber(result.totalEnergy)} kWh
                  </p>
                  <p>
                    <strong>Total Charging Revenue (per month):</strong> RM{" "}
                    {formatNumber(result.totalChargingRevenue)}
                  </p>
                  <p>
                    <strong>Monthly Electricity Cost:</strong> RM{" "}
                    {formatNumber(result.monthlyElectricityCost)}
                  </p>
                  <p>
                    <strong>Monthly Operation Expense (Electricity, Hosting & Maintenance):</strong> RM{" "}
                    {formatNumber(result.monthlyExpenses)}
                  </p>
                  <p>
                    <strong>Gross Profit (Before Profit Sharing):</strong> RM{" "}
                    {formatNumber(result.monthlyGrossProfit)}
                  </p>
                  <p>
                    <strong>Partner Payment (Profit Sharing):</strong> RM{" "}
                    {formatNumber(result.partnerPayment)}
                  </p>
                  <p>
                    <strong>Monthly Net Profit (After Profit Sharing):</strong> RM{" "}
                    {formatNumber(result.monthlyNetProfit)}
                  </p>
                  <p>
                    <strong>Monthly ROI:</strong> {formatNumber(result.monthlyROI)}%
                  </p>
                  <p>
                    <strong>Annual ROI:</strong> {formatNumber(result.annualROI)}%
                  </p>
                  <p>
                    <strong>Total Investment (Setup & Purchase Cost):</strong> RM{" "}
                    {formatNumber(result.totalInvestment)}
                  </p>
                  <p>
                    <strong>Break Even Month:</strong> {getBreakEvenMonth()}
                  </p>
                  <canvas ref={chartRef} width="600" height="400"></canvas>

                  <h4 className="mt-4">Projection (over {projectionMonths} months)</h4>
                  <table className="table table-bordered table-striped">
                    <thead>
                      <tr>
                        <th>Month</th>
                        <th>Setup Cost (RM)</th>
                        <th>Total Revenue (RM)</th>
                        <th>Monthly Operation Expenses (RM)</th>
                        <th>Partner Profit Sharing (RM)</th>
                        <th>Monthly Net Income (RM)</th>
                        <th>Total Net Income (RM)</th>
                      </tr>
                    </thead>
                    <tbody>{renderTableRows()}</tbody>
                  </table>
                </div>
              )}
            </div>
          </div>
        );
      }

      ReactDOM.render(<ROICalculator />, document.getElementById('root'));
    </script>
  </body>
</html>
